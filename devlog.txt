pią, 17 sty 2020, 09:08:51 CET

Jak ja się w to wpakowałem ...  Mniejsza o to.  Mam tutaj stary kod.
Już kiedyś próbowałem dodać plugin do Prettiera.  Mam nadzieję, że od
tamtej pory nic się nie zmieniło w samej mechanice pluginów.  Rzucę
okiem na dokumentację zanim cokolwiek zrobię.

Pierwszym krokiem będzie przechwycenie momentu, w którym Prettier
parsuje zawartość pliku na AST.  W tym miejscu będę musiał wychwycić
JSDocki i też je parsować.

pią, 17 sty 2020, 09:49:49 CET

Zapoznałem się z kodem, dokumentacją i teraz już pamiętam w czym tkwił
problem.  Sytuacja jest skomplikowana i moje wnioski mogą mijać się
z prawdą, ale wygląda na to, że nie da się rozszerzyć istniejącego
parsera.  Można tylko napisać nowy co jest idealne kiedy chcemy dodać
wsparcie dla całego innego języka, ale nie w moim przypadku.

Podobna sytuacje z printerem.  Tutaj też chcę tylko zmodyfikować
funkcję wypisującą kod zamiast pisać całej nowej.  Niestety nie widzę
ku temu sposobności.

Rozważam teraz możliwość napisania parsera i printera do samych
JSDocków.  Można by wtedy uruchamiać Prettiera dwa razy.  Za pierwszym
razem dla samego kodu JS, za drugim dla JSDocków.

Nie podoba mi się takie podejście.  Przechodzenie przez te same pliki
kilka razy jest niewydajne.

pią, 17 sty 2020, 10:16:38 CET

Postanowione.  Napiszę parser do samych JSDocków.  Przynajmniej będę
miał całą logikę odpowiedzialną za parsowanie i formatowanie.  Sprawy
związane z konstruowaniem dodatku do Prettiera pozostawię na koniec.

Coś czuję, że wystarczające okaże się podanie kilku parserów w kodzie
definiującym język.

pią, 17 sty 2020, 10:56:15 CET

Wygląda na to, że można bez przeszkód używać innego parsera wewnątrz
swojego parsera.  Tak uczyniłem i w efekcie dostaję sparsowany kod JS
z wycielonymi komentarzami.  Mogę teraz przejść przez same komentarze
i dodatkowo je parsować.  Pewnie podobnie będzie dało się zrobić
podczas printowania.

                                * * *

Pobrałem repozytorium JSDocka z zamiarem wykorzystania jego własnego
kodu do pluginu parsera.  Przeglądanie innego projektu poszukując
potrzebnych funkcji zabiera cenny czas.

pią, 17 sty 2020, 11:47:51 CET

Zdaje się, że znalazłem główną funkcję parsującą pliki w kodzie
JSDoc.  Zamierzam ją bezwzględnie wykorzystać.  Pierwsze czego mi
trzeba to funkcji znajdującej JSDocki.

pią, 17 sty 2020, 12:50:13 CET

Niestety JSDoc nie jest napisany jak biblioteka i używanie funkcji
bezpośrednio z jego kodu jest uniemożliwione.  Istnieją różne inne
parsery JSDocków.  Sam swojego nie napiszę w tak krótkim czasie więc
muszę z któregoś skorzystać.

pią, 17 sty 2020, 13:12:37 CET

Eh, nie wiem czy się cieszyć czy smucić.  Zrobiłem to.  Działa.
Praktycznie większość tego co chciałem już jest.  Okazało się, że da
się podejść do problemu w niespotykanie prosty sposób bez pisania
dodatku do Prettiera.  Wystarczyła jedna funkcja, która ma około 16
linii kodu.

Nawet nie mam ochoty zagłębiać się w szczegóły.  Przygotuję kod żeby
dało się go zastosować na naszych projektach i zamykam temat.  Pewnie
zejdzie mi na tym jeszcze dużo czasu.  Jak to zwykle bywa ostatnie 20%
pracy zajmuje najwięcej czasu.

pią, 17 sty 2020, 14:25:57 CET

Dodałem więcej przykładowych JSDocków do testowania parsowania.
Obsłużyłem dodatkowe przypadki i dodałem opcję pozwalającą zmienić
ilość spacji oddzielających poszczególne pola.

pią, 17 sty 2020, 14:32:14 CET

Mam chyba już wszystko co chciałem.  Spodziewam się, że nadal jest coś
o czym zapomniałem.  Najlepszym testem będzie użycie kodu na żywym
organizmie.  Przygotuję kod du użytku publicznego i przystąpię do
wdrażania jej na jeden z naszych projektów co powinno zweryfikować
poprawność parsowania i printowania.

pią, 17 sty 2020, 15:06:04 CET

Dodałem parser do naszego głównego projektu.  Odpaliłem.  Dwa razy
wyskoczyły błędy, ale szybko się z nimi uporałem.  Przeszło przez
wszystkie pliki dość szybko.  Patrzę teraz na diffa.  Niestety są
drobne problemy.  Spodziewałem się tego.

Widzę, że jest problem z @description i kolejnością innych tagów.

pią, 17 sty 2020, 15:42:29 CET

@description może występować w formie tagu i w formie zwykłego
tekstu.  Będę faworyzował wersję z tagiem, ale to akurat mniejszy
problem.  Najważniejsze jest ustalenie kolejności i to na tym się
teraz skupię.

pią, 17 sty 2020, 16:30:56 CET

Jest nieźle.  Pozostało lepsze obsłużenie tagu @example i dodawanie
pustej linii po @description.  Jeszcze z jakiegoś powodu nie działają
ustawienia parsera.  To jest bardzo dziwne.

Mimo wszystko kończę na dzisiaj.  Nie ma sensu siedzieć 24h bo pod
wpływem zmęczenia napiszę kod, który będzie potem do przepisania.
Lepiej na spokojnie w weekend trochę jeszcze popracować.

sob, 18 sty 2020, 06:53:12 CET

Nadszedł czas pisania testów.  Jestem na etapie, w którym dodaję
wsparcie dla różnych specyficznych przypadków i planuję przepisać
część kodu.  Dlatego zanim cokolwiek dotknę chce dodać unit testy.

sob, 18 sty 2020, 07:27:03 CET

Mam pierwsze testy.  Już znalazłem kilka dodatkowych przypadków do
pokrycia.  Będzie tak jak pisałem wczoraj "ostatnie 20% pracy zajmuje
najwięcej czasu".

sob, 18 sty 2020, 21:03:13 CET

Testy bardo pomagają w pracy.  Dodałem kilka usprawnień.  Między
innymi obsługę synonimów tagów.  To jeszcze nie koniec.  Kilka tagów
nadal wymaga specjalnego traktowania.

nie, 19 sty 2020, 10:15:53 CET

Źle się dzieje.  Wszystko coraz lepiej i fajnie to już wygląda.  Mam
trzy problemy z czego dwa nie będę w stanie naprawić używając tego
prasera co do tej pory.

Pierwszy najmniejszy problem to długie linie opisów.  Trzeba je
zawijać.  To jeszcze da się zrobić.

Drugi problem to opis tagu @example.  Parser usuwa białe znaki
pierwszej linii opisu przez co dodany do @example kod może mieć złe
wcięcia.  Na to też widzę rozwiązanie.  Może uda się użyć Prettiera na
samym opisie tego tagu.  To byłoby super.

Ostatni problem jest niestety nie do przejścia.  Parser nie
interpretuje domyślnych wartości parametrów funkcji.  Po prostu ich
nie ma.  Szukanie teraz innego parsera może się okazać zgubne.  Pewnie
każdy z nich posiada jakieś wady.  Mimo to poszukam bo tego problemu
nie przeskoczę jeśli informacja się traci.

nie, 19 sty 2020, 10:28:04 CET

Ok sytuacja może nie być aż tak beznadziejna jak mi się wydawało.
Powinienem być w stanie sam wydobyć wartość domyślną parametru.
Potrzebne jest tylko odpowiednie wyrażenie regularne i oryginalny
string  komentarza.

https://www.xkcd.com/208/

nie, 19 sty 2020, 14:48:09 CET

Dobra.  Czyli mam cztery tematy na talerzu.  Patrzę na te wszystkie
smakowite kąski i nie wiem od którego zacząć.  Naprawienie opcji
definiowania ilości spacji, zawijanie wierszy długich opisów, opis dla
tagu @examples czy brakujące wartości domyślne.

                                * * *

Zdecydowałem, że zacznę od przystawki, czyli zawijania wierszy.  Jest
to coś co i tak bardzo chcę żeby działało.  Trochę ciężka sprawa, ale
do zrobienia bo nie potrzebuję żadnych dodatkowych składników.

No więc tego, smacznego.

nie, 19 sty 2020, 15:28:41 CET

Dobra ta przystawka, ale jeszcze całej nie zjadłem.

nie, 19 sty 2020, 16:18:09 CET

Wygląda na to, że zawijanie wierszy w opisach wszystkich tagów (po za
@example bo tam tego nie chcemy) działa wyśmienicie.

Teraz biorę się za opis z @example.  To może być ciężkie ("Macie
problemy z grawitacją?").  Spróbuję po prostu użyć do tego Prettiera.
Powinno się udać.

nie, 19 sty 2020, 16:36:07 CET

Działa!  Przynajmniej w testach.  Nie mogę się doczekać aż uruchomię
to na jednym z projektów w pracy.

Zostało obsłużenie wartości domyślnych i opcji.  Nie ukrywam, że jak
to zrobię to chciałbym jeszcze spróbować zamienić to w plugin.  Tak
będzie łatwiej wspierać Prettiera w edytorach tekstowych.

nie, 19 sty 2020, 19:00:55 CET

Wartość domyślna już działa.  Przynajmniej na moim teście.
Niepotrzebnie wcześniej tak panikowałem.  Prawdziwy test będzie
dopiero na większym projekcie pełnym JSDocków.

Teraz obsługa opcji a na deser zamienię to wszystko w plugin.  Taką
mam nadzieję.
